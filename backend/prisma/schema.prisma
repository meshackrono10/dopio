generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String           @id @default(uuid())
  email               String           @unique
  password            String
  name                String
  phone               String?
  role                Role             @default(TENANT)
  isVerified          Boolean          @default(false)
  verificationStatus  String           @default("UNVERIFIED")
  avatarUrl           String?
  idFrontUrl          String?
  idBackUrl           String?
  selfieUrl           String?
  description         String?          @db.Text
  workLocation        String?          @db.Text
  averageRating       Float            @default(0)
  reviewCount         Int              @default(0)
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  isDeleted           Boolean          @default(false)
  deletedAt           DateTime?
  hunterBookings      Booking[]        @relation("HunterBookings")
  bookings            Booking[]        @relation("TenantBookings")
  hunterConversations Conversation[]   @relation("HunterConversations")
  tenantConversations Conversation[]   @relation("TenantConversations")
  againstDisputes     Dispute[]        @relation("AgainstDisputes")
  reporterDisputes    Dispute[]        @relation("ReporterDisputes")
  hunterEarnings      HunterEarnings[] @relation("HunterEarnings")
  receivedMessages    Message[]        @relation("ReceivedMessages")
  sentMessages        Message[]        @relation("SentMessages")
  paymentHistory      PaymentHistory[] @relation("UserPayments")
  properties          Property[]
  savedProperties     SavedProperty[]
  viewingRequests     ViewingRequest[]
  notifications       Notification[]   @relation("UserNotifications")
}

model Property {
  id                String         @id @default(uuid())
  title             String
  description       String         @db.Text
  rent              Float
  location          String         @db.LongText
  amenities         String         @db.LongText
  images            String         @db.LongText
  videos            String?        @db.LongText
  status            PropertyStatus @default(PENDING_APPROVAL)
  isExactLocation   Boolean        @default(false)
  isLocked          Boolean        @default(false)
  adminApprovedBy   String?
  adminApprovedAt   DateTime?
  rejectionReason   String?        @db.Text
  hunterId          String
  utilities         String?        @db.LongText
  packageProperties String?        @db.LongText
  listingPackage    String? // BRONZE, SILVER, GOLD

  // Package linking fields
  packageGroupId  String? // UUID linking all properties in a package
  packagePosition Int? // 1, 2, or 3 (position in package)
  packageMasterId String? // ID of the master property (position 1)

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  isDeleted         Boolean            @default(false)
  deletedAt         DateTime?
  bookings          Booking[]
  disputes          Dispute[]
  hunter            User               @relation(fields: [hunterId], references: [id])
  savedBy           SavedProperty[]
  packages          ViewingPackage[]
  requests          ViewingRequest[]
  alternativeOffers AlternativeOffer[]

  // Self-referential relations for package grouping
  packageMembers Property[] @relation("PackageGroup")
  packageMaster  Property?  @relation("PackageGroup", fields: [packageMasterId], references: [id], onDelete: SetNull)

  @@index([hunterId], map: "Property_hunterId_fkey")
  @@index([packageGroupId])
  @@index([packageMasterId])
}

model ViewingPackage {
  id                 String      @id @default(uuid())
  name               String
  price              Float
  description        String?
  tier               PackageTier
  propertiesIncluded Int
  features           String      @db.LongText
  propertyId         String
  property           Property    @relation(fields: [propertyId], references: [id])
  requests           ViewingRequest[]

  // Group linking per tier
  packageGroupId  String?
  packagePosition Int?
  packageMasterId String?

  @@index([propertyId], map: "ViewingPackage_propertyId_fkey")
  @@index([packageGroupId])
}

model ViewingRequest {
  id               String        @id @default(uuid())
  propertyId       String
  tenantId         String
  proposedDates    String        @db.LongText
  proposedLocation String?       @db.LongText
  message          String?       @db.Text
  status           RequestStatus @default(PENDING)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  amount           Float?
  paymentStatus    InvoiceStatus @default(UNPAID)
  packageId        String?
  counterDate      String?
  counterTime      String?
  counterLocation  String?       @db.LongText
  counteredBy      String?
  bookingId        String?       @unique
  tenantVisible    Boolean       @default(true)
  hunterVisible    Boolean       @default(true)
  package          ViewingPackage? @relation(fields: [packageId], references: [id])
  property         Property      @relation(fields: [propertyId], references: [id])
  tenant           User          @relation(fields: [tenantId], references: [id])
  booking          Booking?      @relation("RequestToBooking", fields: [bookingId], references: [id])

  @@index([propertyId], map: "ViewingRequest_propertyId_fkey")
  @@index([tenantId], map: "ViewingRequest_tenantId_fkey")
}

model Booking {
  id                       String              @id @default(uuid())
  propertyId               String
  tenantId                 String
  hunterId                 String
  amount                   Float
  paymentStatus            InvoiceStatus       @default(ESCROW)
  scheduledDate            String
  scheduledTime            String
  scheduledEndTime         String
  actualStartTime          DateTime?
  actualEndTime            DateTime?
  autoReleaseAt            DateTime?
  tenantConfirmed          Boolean             @default(false)
  hunterConfirmed          Boolean             @default(false)
  tenantMetConfirmed       Boolean             @default(false)
  hunterMetConfirmed       Boolean             @default(false)
  physicalMeetingConfirmed Boolean             @default(false)
  status                   BookingStatus       @default(CONFIRMED)
  chatEnabled              Boolean             @default(true)
  completedAt              DateTime?
  viewingOutcome           ViewingOutcome?
  outcomeSubmittedAt       DateTime?
  viewingRequest           ViewingRequest?     @relation("RequestToBooking")
  tenantFeedback           String?             @db.Text
  issueEvidence            String?             @db.LongText
  tenantDone               Boolean             @default(false)
  hunterDone               Boolean             @default(false)
  issueCreated             Boolean             @default(false)
  issueReporterId          String?
  issueStatus              String?             @default("PENDING") // PENDING, ACCEPTED, DENIED
  tenantVisible            Boolean             @default(true)
  hunterVisible            Boolean             @default(true)
  createdAt                DateTime            @default(now())
  updatedAt                DateTime            @updatedAt
  hunter                   User                @relation("HunterBookings", fields: [hunterId], references: [id])
  property                 Property            @relation(fields: [propertyId], references: [id])
  tenant                   User                @relation("TenantBookings", fields: [tenantId], references: [id])
  disputes                 Dispute[]
  hunterEarnings           HunterEarnings[]
  meetingPoint             MeetingPoint?
  messages                 Message[]
  rescheduleRequests       RescheduleRequest[]
  reviews                  Review[]
  alternativeOffers        AlternativeOffer[]

  @@index([hunterId], map: "Booking_hunterId_fkey")
  @@index([propertyId], map: "Booking_propertyId_fkey")
  @@index([tenantId], map: "Booking_tenantId_fkey")
}

model AlternativeOffer {
  id               String   @id @default(uuid())
  bookingId        String
  propertyId       String
  viewingRequestId String?  @unique
  message          String?  @db.Text
  status           String   @default("PENDING") // PENDING, ACCEPTED, DECLINED
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  booking          Booking  @relation(fields: [bookingId], references: [id])
  property         Property @relation(fields: [propertyId], references: [id])

  @@index([bookingId], map: "AlternativeOffer_bookingId_fkey")
  @@index([propertyId], map: "AlternativeOffer_propertyId_fkey")
}

model Review {
  id        String     @id @default(uuid())
  bookingId String
  rating    Int
  comment   String?    @db.Text
  type      ReviewType
  createdAt DateTime   @default(now())
  booking   Booking    @relation(fields: [bookingId], references: [id])

  @@index([bookingId], map: "Review_bookingId_fkey")
}

model Message {
  id             String        @id @default(uuid())
  conversationId String?
  bookingId      String?
  senderId       String
  receiverId     String
  propertyId     String?
  content        String?       @db.Text
  type           MessageType   @default(TEXT)
  fileUrl        String?
  fileName       String?
  fileSize       Int?
  callDuration   Int?
  isRead         Boolean       @default(false)
  createdAt      DateTime      @default(now())
  booking        Booking?      @relation(fields: [bookingId], references: [id])
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  receiver       User          @relation("ReceivedMessages", fields: [receiverId], references: [id])
  sender         User          @relation("SentMessages", fields: [senderId], references: [id])

  @@index([senderId])
  @@index([receiverId])
  @@index([bookingId])
  @@index([conversationId])
}

model Dispute {
  id                  String        @id @default(uuid())
  title               String
  description         String        @db.Text
  category            String
  status              DisputeStatus @default(OPEN)
  priority            String        @default("medium")
  reporterId          String
  againstId           String?
  bookingId           String?
  propertyId          String?
  resolution          String?       @db.Text
  evidenceUrls        String?       @db.LongText
  evidenceDescription String?       @db.Text
  hunterEvidenceUrl   String?       @db.LongText
  hunterResponse      String?       @db.Text
  resolvedBy          String?
  resolvedAt          DateTime?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  against             User?         @relation("AgainstDisputes", fields: [againstId], references: [id])
  booking             Booking?      @relation(fields: [bookingId], references: [id])
  property            Property?     @relation(fields: [propertyId], references: [id])
  reporter            User          @relation("ReporterDisputes", fields: [reporterId], references: [id])

  @@index([againstId], map: "Dispute_againstId_fkey")
  @@index([bookingId], map: "Dispute_bookingId_fkey")
  @@index([propertyId], map: "Dispute_propertyId_fkey")
  @@index([reporterId], map: "Dispute_reporterId_fkey")
}

model Conversation {
  id            String    @id @default(uuid())
  tenantId      String
  hunterId      String
  propertyId    String?
  lastMessage   String?   @db.Text
  lastMessageAt DateTime?
  unreadCount   Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  hunter        User      @relation("HunterConversations", fields: [hunterId], references: [id])
  tenant        User      @relation("TenantConversations", fields: [tenantId], references: [id])
  messages      Message[]

  @@unique([tenantId, hunterId, propertyId])
  @@index([hunterId], map: "Conversation_hunterId_fkey")
}

model SavedProperty {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  createdAt  DateTime @default(now())
  property   Property @relation(fields: [propertyId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, propertyId])
  @@index([propertyId], map: "SavedProperty_propertyId_fkey")
}

model PaymentHistory {
  id                 String        @id @default(uuid())
  userId             String
  amount             Float
  type               PaymentType
  mpesaReceiptNumber String?
  phoneNumber        String?
  status             PaymentStatus
  description        String?       @db.Text
  metadata           String?       @db.LongText
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  user               User          @relation("UserPayments", fields: [userId], references: [id])

  @@index([userId], map: "PaymentHistory_userId_fkey")
}

model HunterEarnings {
  id        String         @id @default(uuid())
  hunterId  String
  amount    Float
  bookingId String
  status    EarningsStatus @default(PENDING)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  booking   Booking        @relation(fields: [bookingId], references: [id])
  hunter    User           @relation("HunterEarnings", fields: [hunterId], references: [id])

  @@index([bookingId], map: "HunterEarnings_bookingId_fkey")
  @@index([hunterId], map: "HunterEarnings_hunterId_fkey")
}

model MeetingPoint {
  id             String             @id @default(uuid())
  bookingId      String             @unique
  type           MeetingPointType   @default(LANDMARK)
  location       String             @db.LongText
  sharedBy       String
  sharedAt       DateTime           @default(now())
  status         MeetingPointStatus @default(PENDING)
  tenantViewed   Boolean            @default(false)
  tenantViewedAt DateTime?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  booking        Booking            @relation(fields: [bookingId], references: [id])
}

model RescheduleRequest {
  id               String           @id @default(uuid())
  bookingId        String
  requestedBy      String
  proposedDate     String
  proposedTime     String
  proposedEndTime  String
  proposedLocation String?          @db.Text
  reason           String?          @db.Text
  status           RescheduleStatus @default(PENDING)
  counterDate      String?
  counterTime      String?
  counterEndTime   String?
  counterLocation  String?          @db.Text
  counterReason    String?          @db.Text
  respondedBy      String?
  respondedAt      DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  booking          Booking          @relation(fields: [bookingId], references: [id])

  @@index([bookingId], map: "RescheduleRequest_bookingId_fkey")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  title     String
  message   String   @db.Text
  type      String   @default("info")
  read      Boolean  @default(false)
  actionUrl String?
  createdAt DateTime @default(now())
  user      User     @relation("UserNotifications", fields: [userId], references: [id])

  @@index([userId])
}

enum Role {
  TENANT
  HUNTER
  ADMIN
}

enum PropertyStatus {
  PENDING_APPROVAL
  AVAILABLE
  LOCKED
  RENTED
  REJECTED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  COUNTERED
  CANCELLED
  COMPLETED
}

enum InvoiceStatus {
  UNPAID
  PAID
  ESCROW
  RELEASED
  REFUNDED
}

enum BookingStatus {
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum ReviewType {
  TENANT_TO_HUNTER
  HUNTER_TO_TENANT
}

enum PackageTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum RescheduleStatus {
  PENDING
  ACCEPTED
  REJECTED
  COUNTERED
}

enum MeetingPointStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum MeetingPointType {
  LANDMARK
  PROPERTY
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  VOICE_CALL
  VIDEO_CALL
}

enum DisputeStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum PaymentType {
  BOOKING_PAYMENT
  WITHDRAWAL
  REFUND
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum EarningsStatus {
  PENDING
  WITHDRAWN
}

enum ViewingOutcome {
  COMPLETED_SATISFIED
  ISSUE_REPORTED
  ALTERNATIVE_REQUESTED
}
